/*
 * osada.c
 *
 *  Created on: 9/9/2016
 *      Author: utnso
 */
#include <stdint.h>
#include "osada.h"
#include <stdlib.h>
#include <stdio.h>

void inicializarOSADA(){

}

osada_file *leerArchivoParaOsadaFile(char *ruta){
	osada_file *osadaFile = malloc(sizeof(osada_file));
	FILE * archivo= fopen(ruta, "rb");

	if (archivo != NULL) {
		fread(osadaFile, sizeof(osada_file), 1, archivo);
		fclose(archivo);
	}
	return osadaFile;
}

osada_header *leerArchivoParaHeader(char *ruta){
	osada_header *osadaHeaderFile = malloc(sizeof(osada_header));
	FILE * archivo= fopen(ruta, "rb");

	if (archivo != NULL) {
		fread(osadaHeaderFile, sizeof(osada_header), 1, archivo);
		fclose(archivo);
	}
	return osadaHeaderFile;
}

uint8_t version;
uint32_t fs_blocks; // total amount of blocks
uint32_t bitmap_blocks; // bitmap size in blocks
uint32_t allocations_table_offset; // allocations table's first block number
uint32_t data_blocks; // amount of data blocks
unsigned char padding[40]; // useless bytes just to complete the block size

unsigned char devolverMagicNumbre{
	return magic_number[7];
}

uint8_t devolverVersion(){
	return version;
}

devolverBitMapBlocks

devolverAllocations_table_offset

devolverFSBloques

devolverDataBlocks

devolverPadding


int devolverFSBloques(osada_header *osadaHeader){
	return osadaHeader->fs_blocks;
}
/*FILE SYSTEM */
int devolverTamanio(osada_file *osadaFile){
	return osadaFile->file_size;
}

osada_file_state devolverEstado(osada_file *osadaFile){
	return osadaFile->state;
}

unsigned char devolverNombreDelArchivo(osada_file *osadaFile){
	return osadaFile->fname[OSADA_FILENAME_LENGTH];
}

uint16_t devolverDirectorioPadre(osada_file *osadaFile){
	return osadaFile->parent_directory;
}

uint32_t devolverUltimaMod(osada_file *osadaFile){
	return osadaFile->lastmod;
}

osada_block_pointer devolverPrimerBloque(osada_file *osadaFile){
	return osadaFile->first_block;
}
